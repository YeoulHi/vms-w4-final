이해한 맥락부터 적겠습니다.

이 피드백이 말하는 건 “방향은 맞으니까 구조는 그대로 두고, **운영 시 헷갈릴 수 있는 4군데만 문장으로 못 박자**”예요.
그 4군데가 바로:

1. `updated_at`은 **DB나 Django 모델에서 자동으로** 갱신되게 해라 (지금 예시는 애플리케이션이 항상 NOW() 넣는다고 가정하고 있어서 느슨함)
2. `department`는 DB가 정규화하지 않으니 **ingest/services.py에서 문자열 통일을 반드시 하라**
3. `metric_type`은 테이블로 빼지 않아도 되지만 **“이 값은 시스템이 정한 집합을 쓴다”**라고 문서에 남겨라
4. 인덱스는 선택지 말고 **(year, department) 하나로 고정**해라 — PRD의 조회 패턴이 그거니까

즉, 스키마 자체를 바꾸라는 게 아니라 “이 스키마가 이렇게 생긴 이유”를 더 분명히 써서 나중에 다른 사람이 “왜 마스터가 없지?” “왜 updated_at이 안 바뀌지?” 같은 말을 못 하게 해두자는 뜻입니다.

이제 이 피드백을 반영한 **최종본**을 아래에 정리합니다.

---

## 1. 데이터플로우 (최종)

1. **Admin 업로드 (유저플로우 #2)**

   * Django Admin `/admin/ingest/exceldata/add/`에서 엑셀/CSV 업로드
   * `ingest/services.py`가 pandas로 파싱
   * 각 행에 대해

     1. `normalize_department(raw_department)`로 학과명을 통일
     2. `normalize_metric_type(raw_metric)`으로 시스템 정의 값으로 변환
     3. `INSERT ... ON CONFLICT (year, department, metric_type) DO UPDATE` 실행
   * 트랜잭션 커밋 시점에 DB는 최신 상태가 된다

2. **대시보드 조회 (유저플로우 #3)**

   * `/dashboard/` 접근 시 템플릿이 기본 필터(최신 연도, 전체 학과)를 내려준다
   * 프런트가 `/api/dashboard/chart-data/?year=...&department=...` 호출
   * API가 `metric_records`에서 해당 조건으로 SELECT
   * 결과를 `to_chartjs()`로 변환해 반환

3. **신선도 (유저플로우 #4)**

   * 업로드가 커밋된 이후의 SELECT는 모두 최신 데이터
   * 별도 캐시 없음
   * 사용자가 재접속/새로고침/필터 재적용할 때마다 최신 반영
   * partial commit 시엔 성공 레코드만 노출

4. **인증 (유저플로우 #1)**

   * Django 기본 `auth_user`에서 로그인
   * `is_staff = true`만 업로드 URL 접근 가능
   * DB 스키마 추가 없음

---

## 2. 데이터베이스 스키마 (PostgreSQL, 최종본)

```sql
-- 1. 도메인 테이블
CREATE TABLE metric_records (
    id              BIGSERIAL PRIMARY KEY,
    year            INTEGER NOT NULL,
    department      VARCHAR(100) NOT NULL,
    metric_type     VARCHAR(50)  NOT NULL,
    metric_value    NUMERIC(18,4) NOT NULL,

    created_at      TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at      TIMESTAMPTZ NOT NULL DEFAULT NOW(),

    CONSTRAINT uq_metric_records_business
        UNIQUE (year, department, metric_type)
);

-- 2. 조회 패턴에 맞춘 고정 인덱스
-- PRD가 연도 + 학과 조회를 기본으로 하므로 단일 인덱스 대신 복합 인덱스를 기본값으로 둔다.
CREATE INDEX idx_metric_records_year_department
    ON metric_records (year, department);
```

### 2.1 `updated_at` 자동 갱신 보강

위 스키마는 기본값만 넣었으므로, 실제 프로젝트에서는 **둘 중 하나**로 강제해서 04번(신선도)과 100% 맞춥니다.

**방법 A — Django 모델에서:**

```python
class MetricRecord(models.Model):
    year = models.IntegerField()
    department = models.CharField(max_length=100)
    metric_type = models.CharField(max_length=50)
    metric_value = models.DecimalField(max_digits=18, decimal_places=4)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)  # <- 여기서 강제

    class Meta:
        unique_together = ("year", "department", "metric_type")
```

**방법 B — DB trigger로:**

```sql
CREATE OR REPLACE FUNCTION set_updated_at()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_metric_records_updated_at
BEFORE UPDATE ON metric_records
FOR EACH ROW
EXECUTE FUNCTION set_updated_at();
```

둘 중 하나만 쓰면 됩니다. 이 한 줄이 있어야 “커밋된 순간이 최신”이라는 04번 문서와 실제 DB값이 어긋나지 않습니다.

---

## 3. 앱 레이어에서의 정규화 책임 명시

DB에 master 테이블을 안 둔 대신, **업로드 시점에만** 문자열을 정리한다고 못 박습니다. 이게 방어적 파싱 요구사항과 일치합니다.

```python
# apps/ingest/services.py (개념 스케치)

ALLOWED_DEPARTMENTS = {
    "컴퓨터공학과": "컴퓨터공학과",
    "컴퓨터 공학과": "컴퓨터공학과",
    "컴공과": "컴퓨터공학과",
}

ALLOWED_METRICS = {
    "논문": "PAPER",
    "논문수": "PAPER",
    "예산": "BUDGET",
    "학생수": "STUDENT",
}

def normalize_department(raw: str) -> str:
    raw = (raw or "").strip()
    return ALLOWED_DEPARTMENTS.get(raw, raw)  # 모르는 건 그대로 저장

def normalize_metric_type(raw: str) -> str:
    raw = (raw or "").strip()
    return ALLOWED_METRICS.get(raw, raw)
```

→ 이렇게 하면 **DB는 단순 문자열 테이블**로 남고,
→ **ingest가 책임지고 “가능한 한 같은 값”으로 몰아넣는 구조**가 됩니다.
→ 이게 “DB는 최소, 정규화는 서비스에서”라는 현재 문서 톤과 맞습니다.

---

## 4. 문서에만 남기는 metric_type 도메인

DB에 ENUM을 만들지 않았으므로, PRD나 `/docs/domain/metrics.md` 같은 곳에 아래처럼만 남기면 됩니다.

```markdown
# metric_type 도메인 (MVP)

- PAPER    : 논문 수
- BUDGET   : 예산
- STUDENT  : 재학생/학생 수
- PROJECT  : 연구/과제 실적

※ 위 목록은 대시보드에서 시각화 대상으로 삼는 시스템 정의 값이다.
※ 엑셀에 이 값과 다른 문자열이 오면 ingest 단계에서 가능한 값으로 치환하고, 치환 불가하면 원문 그대로 저장한다.
```

이렇게 하면 “왜 VARCHAR(50)인데 값이 4개뿐이냐?”는 질문을 막을 수 있습니다.

---

## 5. 최종 요약

* **테이블 수**: 도메인 1개(`metric_records`), 나머지는 Django 기본 테이블 사용
* **키 구조**: PK = id, 비즈니스 유니크 = (year, department, metric_type)
* **인덱스**: (year, department) 한 개만 **고정**
* **업데이트 타임**: 모델 `auto_now=True` 또는 DB trigger로 **항상 갱신**
* **정규화 위치**: DB가 아니라 `ingest/services.py`에서 **문자열 정규화**
* **확장성**: 마스터/로그/캐시는 **문서에만**, 구현 금지
* **출처 일치**: 클라이언트 요구(엑셀→시각화), PRD의 페이지 구조, Code-Structure의 ingest/dashboard 2앱 구조, requirement의 “1년차 MVP + 최소 복잡도”와 모두 동일

이 상태면 실제로 `python manage.py makemigrations` 해도 되는 수준의 최소 스펙이고, 주어진 유저플로우 01~04에 등장한 데이터만 포함한 **최종본**입니다.
